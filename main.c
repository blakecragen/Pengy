#include "main.h"
#include "images/fall.h"
#include "images/leftStep.h"
#include "images/rightStep.h"
#include "images/leftDown.h"
#include "images/rightDown.h"
#include "images/trip.h"
#include "images/directions.h"
#include "images/standing.h"
#include "images/playBackground.h"
#include "images/snowball.h"

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  DIRECTIONS,
  WIN,
  END,
};

char* intToChar(int t) {
  static char start[12];
  for (int i = 0; i < 12; ++i) {
    start[i] = '\0';
  }
  int pos = 0;
  int length = 0;
  int timeCopy = t;
  int currentDigit;
  while (timeCopy > 0) {
    length++;
    timeCopy /= 10;
  }
  
  int divisor = 1;
  for (int i = 1; i < length; ++i) {
    divisor *= 10;
  }
  //time = 11, len = 2, divisor = 10
  for (int i = 0; i < length; ++i) {
    currentDigit = t / divisor;
    t -= currentDigit * divisor;
    currentDigit += 48;
    start[pos] = (char) currentDigit;
    pos++;
    divisor /= 10;
  }
  return start;
}










int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;
  // Load initial application state
  int lossShow = 0;
  enum gba_state state = START;
  struct player p;
  p.leftCol = 40;
  p.topRow = 90;
  p.height = 50;
  p.width = 40;
  p.speed = 3;
  p.state = RIGHTDOWN;
  int pengyOut = 0;
  int timer = 0;
  int timePlayed = 0;
  int img = 1;
  struct currentEnemies enemies;
  enemies.width = 30;
  enemies.height = 30;
  enemies.speed = 1;
  enemies.ballsLeftTillSpeedup = 10;
  enemies.ballsLeftUntilIncreasedFreq = 7;
  enemies.timeBetween = 4;
  enemies.numEnemies = 0;
  enemies.maxNumEnemies = 10;
  enemies.timeFromLast = 0;
  enemies.topLayerLeftCol = 190;
  enemies.topLayerTopRow = 45;
  enemies.botLayerLeftCol = 190;
  enemies.botLayerTopRow =110;
  enemies.whereAddNextEnemy = 0;
  int first = 0;
  int second = 0;
  int third = 0;
  
  
  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();
    switch (state) {
      case START:
        pengyOut = 0;
        drawFullScreenImageDMA(startBackground);
        drawImageDMA(0, 80, 80, 80, startScreen);
        drawRectDMA(0, 140, 240, 10, WHITE);
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = DIRECTIONS;
          fillScreenDMA(BLACK);
          drawFullScreenImageDMA(directions);
          drawImageDMA(0, 80, 80, 80, startScreen);
          drawRectDMA(0, 80, 240, 10, WHITE);
          drawRectDMA(0, 140, 240, 10, WHITE);
        }
        break;
      
      
      
      case DIRECTIONS:
        if (KEY_DOWN(BUTTON_DOWN, currentButtons) && (pengyOut == 0)) {
          undrawImageDMA(100, 0, 80, 40, directions);
          drawImageDMA(p.leftCol, p.topRow, 40, 50, standing);
          waitForVBlank();
        }
        if (KEY_DOWN(BUTTON_UP, currentButtons) && (pengyOut == 0)) {
          undrawImageDMA(100, 0, 80, 40, directions);
          drawImageDMA(p.leftCol, p.topRow, 40, 50, standing);
          waitForVBlank();
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons) && (pengyOut == 0)) {
          undrawImageDMA(100, 0, 80, 40, directions);
          drawImageDMA(p.leftCol, p.topRow, 40, 50, standing);
        }
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && (pengyOut == 0)) {
          undrawImageDMA(100, 0, 80, 40, directions);
          drawImageDMA(p.leftCol, p.topRow, 40, 50, standing);
        }
        
        
        
        
        
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          undrawImageDMA(p.topRow, p.leftCol, 40, 50, directions);
          if (p.leftCol < 180) {
            p.leftCol += p.speed;
          }
          drawImageDMA(p.leftCol, p.topRow, 40, 50, standing);
          waitForVBlank();
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          undrawImageDMA(p.topRow, p.leftCol, 40, 50, directions);
          if (p.leftCol > 3) {
            p.leftCol -= p.speed;
          }
          drawImageDMA(p.leftCol, p.topRow, 40, 50, standing);
          waitForVBlank();
        }
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          undrawImageDMA(p.topRow, p.leftCol, 40, 50, directions);
          if (p.topRow == 90) {
            p.topRow -= 60;
          }
          drawImageDMA(p.leftCol, p.topRow, 40, 50, standing);
          waitForVBlank();
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          undrawImageDMA(p.topRow, p.leftCol, 40, 50, directions);
          if (p.topRow == 30) {
            p.topRow += 60;
          }
          drawImageDMA(p.leftCol, p.topRow, 40, 50, standing);
          waitForVBlank();
        }
        
        
        
        
        
        
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
          drawFullScreenImageDMA(playBackground);
          drawRectDMA(0, 80, 240, 10, WHITE);
          drawRectDMA(0, 140, 240, 10, WHITE);
          p.leftCol = 40;
          p.topRow = 90;
        }
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          timer = 0;
          timePlayed = 0;
          for (int i = 0; i < enemies.numEnemies; ++i) {
            enemies.e[i].topRow = -1;
          }
          enemies.numEnemies = 0;
          enemies.whereAddNextEnemy = 0;
          lossShow = 0;
          enemies.speed = 1;
          enemies.ballsLeftTillSpeedup = 10;
          enemies.ballsLeftUntilIncreasedFreq = 7;
          enemies.timeBetween = 4;
          p.leftCol = 40;
          p.topRow = 90;
        }
        break;
      
      
      
      
      
      
      
      case PLAY:
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          undrawImageDMA(p.topRow, p.leftCol, 40, 50, playBackground);
          if (p.leftCol < 180) {
            p.leftCol += p.speed;
          }
          if (img == 1) {
            drawImageDMA(p.leftCol, p.topRow, 40, 50, leftDown);
          } else {
            drawImageDMA(p.leftCol, p.topRow, 40, 50, rightDown);
          }
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          undrawImageDMA(p.topRow, p.leftCol, 40, 50, playBackground);
          if (p.leftCol > 3) {
            p.leftCol -= p.speed;
          }
          if (img == 1) {
            drawImageDMA(p.leftCol, p.topRow, 40, 50, leftDown);
          } else {
            drawImageDMA(p.leftCol, p.topRow, 40, 50, rightDown);
          }
        }
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          undrawImageDMA(p.topRow, p.leftCol, 40, 50, playBackground);
          if (p.topRow == 90) {
            p.topRow -= 60;
          }
          if (img == 1) {
            drawImageDMA(p.leftCol, p.topRow, 40, 50, leftDown);
          } else {
            drawImageDMA(p.leftCol, p.topRow, 40, 50, rightDown);
          }
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          undrawImageDMA(p.topRow, p.leftCol, 40, 50, playBackground);
          if (p.topRow == 30) {
            p.topRow += 60;
          }
          if (img == 1) {
            drawImageDMA(p.leftCol, p.topRow, 40, 50, leftDown);
          } else {
            drawImageDMA(p.leftCol, p.topRow, 40, 50, rightDown);
          };
        }
        if (img == 1) {
          drawImageDMA(p.leftCol, p.topRow, 40, 50, leftDown);
        } else {
          drawImageDMA(p.leftCol, p.topRow, 40, 50, rightDown);
        };
        
        
        //Timer Logic
        if (timer > 50) {
          if (img == 1) {
            img = 2;
          } else {
            img = 1;
          }
          timer %= 50;
          timePlayed += 1;
          enemies.timeFromLast++;
          undrawImageDMA(5, 200, 24, 8, playBackground);
          drawString(5, 200, intToChar(timePlayed), WHITE);
        }
        
        
        
        //Enemy logic
        if ((enemies.numEnemies == 0) || (enemies.timeFromLast == enemies.timeBetween)) {
          
          struct enemy e;
          if (p.topRow == 90) {
            e.topRow = 90;
          } else if (p.topRow == 30) {
            e.topRow = 30;
          }
          e.leftCol = enemies.botLayerLeftCol;
          
          enemies.timeFromLast = 0;
          enemies.e[enemies.whereAddNextEnemy] = e;
          enemies.numEnemies++;
          enemies.whereAddNextEnemy++;
          enemies.ballsLeftTillSpeedup--;
          enemies.ballsLeftUntilIncreasedFreq--;
        }
        
        if (enemies.ballsLeftTillSpeedup == 0 && enemies.speed < 8) {
          enemies.speed++;
          enemies.ballsLeftTillSpeedup = 10;
        }
        
        if (enemies.ballsLeftUntilIncreasedFreq == 0 && enemies.timeBetween > 1) {
          enemies.timeBetween--;
          enemies.ballsLeftUntilIncreasedFreq = 7;
        }
        
        
        if (enemies.whereAddNextEnemy == enemies.maxNumEnemies) {
          enemies.whereAddNextEnemy = 0;
        }
        for (int i = 0; i < enemies.maxNumEnemies; ++i) {
          if (enemies.e[i].topRow > 0) {
            undrawImageDMA(enemies.e[i].topRow, enemies.e[i].leftCol, enemies.width, enemies.height, playBackground);
            enemies.e[i].leftCol -= enemies.speed;
            drawImageDMA(enemies.e[i].leftCol, enemies.e[i].topRow, enemies.width, enemies.height, snowball);
            if (enemies.e[i].leftCol <= 10) {
              undrawImageDMA(enemies.e[i].topRow, enemies.e[i].leftCol, enemies.width, enemies.height, playBackground);
              enemies.e[i].topRow = -1;
            }
          }
          
          // Check for colision:
          if (p.topRow == enemies.e[i].topRow) {
            //Checks the left side for collision
            if (((p.leftCol + p.width) > (enemies.e[i].leftCol)) && (p.leftCol < enemies.e[i].leftCol)) {
              state = END;
            }
            //Checks the right side for collision
            if (((p.leftCol + p.width) > (enemies.e[i].leftCol + enemies.width)) && (p.leftCol < (enemies.e[i].leftCol + enemies.width))) {
              state = END;
            }
          }
        }
        
        
        
        timer++;
        waitForVBlank();
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          timer = 0;
          timePlayed = 0;
          for (int i = 0; i < enemies.numEnemies; ++i) {
            enemies.e[i].topRow = -1;
          }
          enemies.numEnemies = 0;
          enemies.whereAddNextEnemy = 0;
          lossShow = 0;
          enemies.speed = 1;
          enemies.ballsLeftTillSpeedup = 10;
          enemies.ballsLeftUntilIncreasedFreq = 7;
          enemies.timeBetween = 4;
          p.leftCol = 40;
          p.topRow = 90;
        }
        break;
      
      
      
      
      case END:
        if (lossShow == 0) {
          if (timePlayed > first) {
            third = second;
            second = first;
            first = timePlayed;
          } else if (timePlayed > second) {
            third = second;
            second = timePlayed;
          } else if (timePlayed > third) {
            third = timePlayed;
          }
          fillScreenDMA(BLACK);
          waitForVBlank();
          //Len: 22
          drawString(40, 66,"You got hit... Unlucky", WHITE);
          drawString(50, 96,"1st Place: ", WHITE);
          drawString(50, 162, intToChar(first), WHITE);
          drawString(60, 96,"2nd Place: ", WHITE);
          drawString(60, 162, intToChar(second), WHITE);
          drawString(70, 96,"3rd Place: ", WHITE);
          drawString(70, 162, intToChar(third), WHITE);
          //Len: 21
          drawString(80, 69, "Press Select to Reset", WHITE);
          lossShow = 1;
        }
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          p.leftCol = 40;
          p.topRow = 90;
          timer = 0;
          timePlayed = 0;
          for (int i = 0; i < enemies.numEnemies; ++i) {
            enemies.e[i].topRow = -1;
          }
          enemies.numEnemies = 0;
          enemies.whereAddNextEnemy = 0;
          lossShow = 0;
          enemies.speed = 1;
          enemies.ballsLeftTillSpeedup = 10;
          enemies.ballsLeftUntilIncreasedFreq = 7;
          enemies.timeBetween = 4;
          state = START;
        }
        break;
      
      
      
      
      
      
      case WIN:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          p.leftCol = 40;
          p.topRow = 90;
          state = START;
          timer = 0;
          timePlayed = 0;
          for (int i = 0; i < enemies.numEnemies; ++i) {
            enemies.e[i].topRow = -1;
          }
          enemies.numEnemies = 0;
          enemies.whereAddNextEnemy = 0;
          lossShow = 0;
          enemies.speed = 1;
          enemies.ballsLeftTillSpeedup = 10;
          enemies.ballsLeftUntilIncreasedFreq = 7;
          enemies.timeBetween = 4;
        }
        fillScreenDMA(BLACK);
        drawString(10, 10, intToChar(timePlayed), WHITE);
        // state = ?
        break;
    }
    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}
